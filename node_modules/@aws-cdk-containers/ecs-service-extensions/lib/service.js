"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const ecs = require("@aws-cdk/aws-ecs");
const extension_interfaces_1 = require("./extensions/extension-interfaces");
// keep this import separate from other imports to reduce chance for merge conflicts with v2-main
// eslint-disable-next-line no-duplicate-imports, import/order
const core_1 = require("@aws-cdk/core");
/**
 * This Service construct serves as a Builder class for an ECS service. It
 * supports various extensions and keeps track of any mutating state, allowing
 * it to build up an ECS service progressively.
 */
class Service extends core_1.Construct {
    constructor(scope, id, props) {
        super(scope, id);
        /**
         * The list of URLs associated with this service.
         */
        this.urls = {};
        this.scope = scope;
        this.id = id;
        this.environment = props.environment;
        this.vpc = props.environment.vpc;
        this.cluster = props.environment.cluster;
        this.capacityType = props.environment.capacityType;
        this.serviceDescription = props.serviceDescription;
        // Check to make sure that the user has actually added a container
        const containerextension = this.serviceDescription.get('service-container');
        if (!containerextension) {
            throw new Error(`Service '${this.id}' must have a Container extension`);
        }
        // First set the scope for all the extensions
        for (const extensions in this.serviceDescription.extensions) {
            if (this.serviceDescription.extensions[extensions]) {
                this.serviceDescription.extensions[extensions].prehook(this, this.scope);
            }
        }
        // At the point of preparation all extensions have been defined on the service
        // so give each extension a chance to now add hooks to other extensions if
        // needed
        for (const extensions in this.serviceDescription.extensions) {
            if (this.serviceDescription.extensions[extensions]) {
                this.serviceDescription.extensions[extensions].addHooks();
            }
        }
        // Give each extension a chance to mutate the task def creation properties
        let taskDefProps = {
            // Default CPU and memory
            cpu: '256',
            memory: '512',
            // Allow user to pre-define the taskRole so that it can be used in resource policies that may
            // be defined before the ECS service exists in a CDK application
            taskRole: props.taskRole,
            // Ensure that the task definition supports both EC2 and Fargate
            compatibility: ecs.Compatibility.EC2_AND_FARGATE,
        };
        for (const extensions in this.serviceDescription.extensions) {
            if (this.serviceDescription.extensions[extensions]) {
                taskDefProps = this.serviceDescription.extensions[extensions].modifyTaskDefinitionProps(taskDefProps);
            }
        }
        // Now that the task definition properties are assembled, create it
        this.taskDefinition = new ecs.TaskDefinition(this.scope, `${this.id}-task-definition`, taskDefProps);
        // Now give each extension a chance to use the task definition
        for (const extensions in this.serviceDescription.extensions) {
            if (this.serviceDescription.extensions[extensions]) {
                this.serviceDescription.extensions[extensions].useTaskDefinition(this.taskDefinition);
            }
        }
        // Now that all containers are created, give each extension a chance
        // to bake its dependency graph
        for (const extensions in this.serviceDescription.extensions) {
            if (this.serviceDescription.extensions[extensions]) {
                this.serviceDescription.extensions[extensions].resolveContainerDependencies();
            }
        }
        // Give each extension a chance to mutate the service props before
        // service creation
        let serviceProps = {
            cluster: this.cluster,
            taskDefinition: this.taskDefinition,
            minHealthyPercent: 100,
            maxHealthyPercent: 200,
            desiredCount: 1,
        };
        for (const extensions in this.serviceDescription.extensions) {
            if (this.serviceDescription.extensions[extensions]) {
                serviceProps = this.serviceDescription.extensions[extensions].modifyServiceProps(serviceProps);
            }
        }
        // If a maxHealthyPercent and desired count has been set while minHealthyPercent == 100% then we
        // need to do some failsafe checking to ensure that the maxHealthyPercent
        // actually allows a rolling deploy. Otherwise it is possible to end up with
        // blocked deploys that can take no action because minHealtyhPercent == 100%
        // prevents running, healthy tasks from being stopped, but a low maxHealthyPercent
        // can also prevents new parallel tasks from being started.
        if (serviceProps.maxHealthyPercent && serviceProps.desiredCount && serviceProps.minHealthyPercent && serviceProps.minHealthyPercent == 100) {
            if (serviceProps.desiredCount == 1) {
                // If there is one task then we must allow max percentage to be at
                // least 200% for another replacement task to be added
                serviceProps = {
                    ...serviceProps,
                    maxHealthyPercent: Math.max(200, serviceProps.maxHealthyPercent),
                };
            }
            else if (serviceProps.desiredCount <= 3) {
                // If task count is 2 or 3 then max percent must be at least 150% to
                // allow one replacement task to be launched at a time.
                serviceProps = {
                    ...serviceProps,
                    maxHealthyPercent: Math.max(150, serviceProps.maxHealthyPercent),
                };
            }
            else {
                // For anything higher than 3 tasks set max percent to at least 125%
                // For 4 tasks this will allow exactly one extra replacement task
                // at a time, for any higher task count it will allow 25% of the tasks
                // to be replaced at a time.
                serviceProps = {
                    ...serviceProps,
                    maxHealthyPercent: Math.max(125, serviceProps.maxHealthyPercent),
                };
            }
        }
        // Now that the service props are determined we can create
        // the service
        if (this.capacityType === extension_interfaces_1.EnvironmentCapacityType.EC2) {
            this.ecsService = new ecs.Ec2Service(this.scope, `${this.id}-service`, serviceProps);
        }
        else if (this.capacityType === extension_interfaces_1.EnvironmentCapacityType.FARGATE) {
            this.ecsService = new ecs.FargateService(this.scope, `${this.id}-service`, serviceProps);
        }
        else {
            throw new Error(`Unknown capacity type for service ${this.id}`);
        }
        // Now give all extensions a chance to use the service
        for (const extensions in this.serviceDescription.extensions) {
            if (this.serviceDescription.extensions[extensions]) {
                this.serviceDescription.extensions[extensions].useService(this.ecsService);
            }
        }
    }
    /**
     * Tell extensions from one service to connect to extensions from
     * another sevice if they have implemented a hook for it.
     *
     * @param service
     */
    connectTo(service) {
        for (const extensions in this.serviceDescription.extensions) {
            if (this.serviceDescription.extensions[extensions]) {
                this.serviceDescription.extensions[extensions].connectToService(service);
            }
        }
    }
    /**
     * This method adds a new URL for the service. This allows extensions to
     * submit a URL for the service. For example, a load balancer might add its
     * URL, or App Mesh can add its DNS name for the service.
     *
     * @param urlName - The identifier name for this URL
     * @param url - The URL itself.
     */
    addURL(urlName, url) {
        this.urls[urlName] = url;
    }
    /**
     * Retrieve a URL for the service. The URL must have previously been
     * stored by one of the URL providing extensions.
     *
     * @param urlName - The URL to look up.
     */
    getURL(urlName) {
        if (!this.urls[urlName]) {
            throw new Error(`Unable to find a URL with name '${urlName}'`);
        }
        return this.urls[urlName];
    }
}
exports.Service = Service;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0Esd0NBQXdDO0FBSXhDLDRFQUEwRjtBQUcxRixpR0FBaUc7QUFDakcsOERBQThEO0FBQzlELHdDQUEwQztBQXdCMUM7Ozs7R0FJRztBQUNILE1BQWEsT0FBUSxTQUFRLGdCQUFTO0lBbURwQyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQW1CO1FBQzNELEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFSbkI7O1dBRUc7UUFDSyxTQUFJLEdBQTJCLEVBQUUsQ0FBQztRQU94QyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUNiLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQztRQUNyQyxJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUM7UUFDekMsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQztRQUNuRCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFDLGtCQUFrQixDQUFDO1FBRW5ELGtFQUFrRTtRQUNsRSxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUU1RSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLElBQUksQ0FBQyxFQUFFLG1DQUFtQyxDQUFDLENBQUM7U0FDekU7UUFFRCw2Q0FBNkM7UUFDN0MsS0FBSyxNQUFNLFVBQVUsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMs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QztJQUMzQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsT0FBZTtRQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1NBQ2hFO1FBRUQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzVCLENBQUM7Q0FDRjtBQXJPRCwwQkFxT0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBlYzIgZnJvbSAnQGF3cy1jZGsvYXdzLWVjMic7XG5pbXBvcnQgKiBhcyBlY3MgZnJvbSAnQGF3cy1jZGsvYXdzLWVjcyc7XG5pbXBvcnQgKiBhcyBpYW0gZnJvbSAnQGF3cy1jZGsvYXdzLWlhbSc7XG5pbXBvcnQgKiBhcyBjZGsgZnJvbSAnQGF3cy1jZGsvY29yZSc7XG5pbXBvcnQgeyBJRW52aXJvbm1lbnQgfSBmcm9tICcuL2Vudmlyb25tZW50JztcbmltcG9ydCB7IEVudmlyb25tZW50Q2FwYWNpdHlUeXBlLCBTZXJ2aWNlQnVpbGQgfSBmcm9tICcuL2V4dGVuc2lvbnMvZXh0ZW5zaW9uLWludGVyZmFjZXMnO1xuaW1wb3J0IHsgU2VydmljZURlc2NyaXB0aW9uIH0gZnJvbSAnLi9zZXJ2aWNlLWRlc2NyaXB0aW9uJztcblxuLy8ga2VlcCB0aGlzIGltcG9ydCBzZXBhcmF0ZSBmcm9tIG90aGVyIGltcG9ydHMgdG8gcmVkdWNlIGNoYW5jZSBmb3IgbWVyZ2UgY29uZmxpY3RzIHdpdGggdjItbWFpblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGxpY2F0ZS1pbXBvcnRzLCBpbXBvcnQvb3JkZXJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ0Bhd3MtY2RrL2NvcmUnO1xuXG4vKipcbiAqIFRoZSBzZXR0aW5ncyBmb3IgYW4gRUNTIFNlcnZpY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZVByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBTZXJ2aWNlRGVzY3JpcHRpb24gdXNlZCB0byBidWlsZCB0aGUgc2VydmljZS5cbiAgICovXG4gIHJlYWRvbmx5IHNlcnZpY2VEZXNjcmlwdGlvbjogU2VydmljZURlc2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgZW52aXJvbm1lbnQgdG8gbGF1bmNoIHRoZSBzZXJ2aWNlIGluLlxuICAgKi9cbiAgcmVhZG9ubHkgZW52aXJvbm1lbnQ6IElFbnZpcm9ubWVudFxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgSUFNIHJvbGUgdGhhdCBncmFudHMgY29udGFpbmVycyBpbiB0aGUgdGFzayBwZXJtaXNzaW9uIHRvIGNhbGwgQVdTIEFQSXMgb24geW91ciBiZWhhbGYuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQSB0YXNrIHJvbGUgaXMgYXV0b21hdGljYWxseSBjcmVhdGVkIGZvciB5b3UuXG4gICAqL1xuICByZWFkb25seSB0YXNrUm9sZT86IGlhbS5JUm9sZTtcbn1cblxuLyoqXG4gKiBUaGlzIFNlcnZpY2UgY29uc3RydWN0IHNlcnZlcyBhcyBhIEJ1aWxkZXIgY2xhc3MgZm9yIGFuIEVDUyBzZXJ2aWNlLiBJdFxuICogc3VwcG9ydHMgdmFyaW91cyBleHRlbnNpb25zIGFuZCBrZWVwcyB0cmFjayBvZiBhbnkgbXV0YXRpbmcgc3RhdGUsIGFsbG93aW5nXG4gKiBpdCB0byBidWlsZCB1cCBhbiBFQ1Mgc2VydmljZSBwcm9ncmVzc2l2ZWx5LlxuICovXG5leHBvcnQgY2xhc3MgU2VydmljZSBleHRlbmRzIENvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyBFQ1Mgc2VydmljZSB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgcHVibGljIGVjc1NlcnZpY2UhOiBlY3MuRWMyU2VydmljZSB8IGVjcy5GYXJnYXRlU2VydmljZTtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFZQQyB3aGVyZSB0aGlzIHNlcnZpY2Ugc2hvdWxkIGJlIHBsYWNlZC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB2cGM6IGVjMi5JVnBjO1xuXG4gIC8qKlxuICAgKiBUaGUgY2x1c3RlciB0aGF0IGlzIHByb3ZpZGluZyBjYXBhY2l0eSBmb3IgdGhpcyBzZXJ2aWNlLlxuICAgKiBbZGlzYWJsZS1hd3NsaW50OnJlZi12aWEtaW50ZXJmYWNlXVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNsdXN0ZXI6IGVjcy5JQ2x1c3RlcjtcblxuICAvKipcbiAgICogVGhlIGNhcGFjaXR5IHR5cGUgdGhhdCB0aGlzIHNlcnZpY2Ugd2lsbCB1c2UuXG4gICAqIFZhbGlkIHZhbHVlcyBhcmUgRUMyIG9yIEZBUkdBVEUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY2FwYWNpdHlUeXBlOiBFbnZpcm9ubWVudENhcGFjaXR5VHlwZTtcblxuICAvKipcbiAgICogVGhlIFNlcnZpY2VEZXNjcmlwdGlvbiB1c2VkIHRvIGJ1aWxkIHRoaXMgc2VydmljZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzZXJ2aWNlRGVzY3JpcHRpb246IFNlcnZpY2VEZXNjcmlwdGlvbjtcblxuICAvKipcbiAgICogVGhlIGVudmlyb25tZW50IHdoZXJlIHRoaXMgc2VydmljZSB3YXMgbGF1bmNoZWQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZW52aXJvbm1lbnQ6IElFbnZpcm9ubWVudDtcblxuICAvKipcbiAgICogVGhlIGdlbmVyYXRlZCB0YXNrIGRlZmluaXRpb24gZm9yIHRoaXMgc2VydmljZS4gSXQgaXMgb25seVxuICAgKiBnZW5lcmF0ZWQgYWZ0ZXIgLnByZXBhcmUoKSBoYXMgYmVlbiBleGVjdXRlZC5cbiAgICovXG4gIHByb3RlY3RlZCB0YXNrRGVmaW5pdGlvbiE6IGVjcy5UYXNrRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgVVJMcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBzZXJ2aWNlLlxuICAgKi9cbiAgcHJpdmF0ZSB1cmxzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgcHJpdmF0ZSByZWFkb25seSBzY29wZTogY2RrLkNvbnN0cnVjdDtcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogU2VydmljZVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5lbnZpcm9ubWVudCA9IHByb3BzLmVudmlyb25tZW50O1xuICAgIHRoaXMudnBjID0gcHJvcHMuZW52aXJvbm1lbnQudnBjO1xuICAgIHRoaXMuY2x1c3RlciA9IHByb3BzLmVudmlyb25tZW50LmNsdXN0ZXI7XG4gICAgdGhpcy5jYXBhY2l0eVR5cGUgPSBwcm9wcy5lbnZpcm9ubWVudC5jYXBhY2l0eVR5cGU7XG4gICAgdGhpcy5zZXJ2aWNlRGVzY3JpcHRpb24gPSBwcm9wcy5zZXJ2aWNlRGVzY3JpcHRpb247XG5cbiAgICAvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdXNlciBoYXMgYWN0dWFsbHkgYWRkZWQgYSBjb250YWluZXJcbiAgICBjb25zdCBjb250YWluZXJleHRlbnNpb24gPSB0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5nZXQoJ3NlcnZpY2UtY29udGFpbmVyJyk7XG5cbiAgICBpZiAoIWNvbnRhaW5lcmV4dGVuc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2aWNlICcke3RoaXMuaWR9JyBtdXN0IGhhdmUgYSBDb250YWluZXIgZXh0ZW5zaW9uYCk7XG4gICAgfVxuXG4gICAgLy8gRmlyc3Qgc2V0IHRoZSBzY29wZSBmb3IgYWxsIHRoZSBleHRlbnNpb25zXG4gICAgZm9yIChjb25zdCBleHRlbnNpb25zIGluIHRoaXMuc2VydmljZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zW2V4dGVuc2lvbnNdKSB7XG4gICAgICAgIHRoaXMuc2VydmljZURlc2NyaXB0aW9uLmV4dGVuc2lvbnNbZXh0ZW5zaW9uc10ucHJlaG9vayh0aGlzLCB0aGlzLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdCB0aGUgcG9pbnQgb2YgcHJlcGFyYXRpb24gYWxsIGV4dGVuc2lvbnMgaGF2ZSBiZWVuIGRlZmluZWQgb24gdGhlIHNlcnZpY2VcbiAgICAvLyBzbyBnaXZlIGVhY2ggZXh0ZW5zaW9uIGEgY2hhbmNlIHRvIG5vdyBhZGQgaG9va3MgdG8gb3RoZXIgZXh0ZW5zaW9ucyBpZlxuICAgIC8vIG5lZWRlZFxuICAgIGZvciAoY29uc3QgZXh0ZW5zaW9ucyBpbiB0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlRGVzY3JpcHRpb24uZXh0ZW5zaW9uc1tleHRlbnNpb25zXSkge1xuICAgICAgICB0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zW2V4dGVuc2lvbnNdLmFkZEhvb2tzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2l2ZSBlYWNoIGV4dGVuc2lvbiBhIGNoYW5jZSB0byBtdXRhdGUgdGhlIHRhc2sgZGVmIGNyZWF0aW9uIHByb3BlcnRpZXNcbiAgICBsZXQgdGFza0RlZlByb3BzID0ge1xuICAgICAgLy8gRGVmYXVsdCBDUFUgYW5kIG1lbW9yeVxuICAgICAgY3B1OiAnMjU2JyxcbiAgICAgIG1lbW9yeTogJzUxMicsXG5cbiAgICAgIC8vIEFsbG93IHVzZXIgdG8gcHJlLWRlZmluZSB0aGUgdGFza1JvbGUgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiByZXNvdXJjZSBwb2xpY2llcyB0aGF0IG1heVxuICAgICAgLy8gYmUgZGVmaW5lZCBiZWZvcmUgdGhlIEVDUyBzZXJ2aWNlIGV4aXN0cyBpbiBhIENESyBhcHBsaWNhdGlvblxuICAgICAgdGFza1JvbGU6IHByb3BzLnRhc2tSb2xlLFxuXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgdGFzayBkZWZpbml0aW9uIHN1cHBvcnRzIGJvdGggRUMyIGFuZCBGYXJnYXRlXG4gICAgICBjb21wYXRpYmlsaXR5OiBlY3MuQ29tcGF0aWJpbGl0eS5FQzJfQU5EX0ZBUkdBVEUsXG4gICAgfSBhcyBlY3MuVGFza0RlZmluaXRpb25Qcm9wcztcblxuICAgIGZvciAoY29uc3QgZXh0ZW5zaW9ucyBpbiB0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlRGVzY3JpcHRpb24uZXh0ZW5zaW9uc1tleHRlbnNpb25zXSkge1xuICAgICAgICB0YXNrRGVmUHJvcHMgPSB0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zW2V4dGVuc2lvbnNdLm1vZGlmeVRhc2tEZWZpbml0aW9uUHJvcHModGFza0RlZlByb3BzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3cgdGhhdCB0aGUgdGFzayBkZWZpbml0aW9uIHByb3BlcnRpZXMgYXJlIGFzc2VtYmxlZCwgY3JlYXRlIGl0XG4gICAgdGhpcy50YXNrRGVmaW5pdGlvbiA9IG5ldyBlY3MuVGFza0RlZmluaXRpb24odGhpcy5zY29wZSwgYCR7dGhpcy5pZH0tdGFzay1kZWZpbml0aW9uYCwgdGFza0RlZlByb3BzKTtcblxuICAgIC8vIE5vdyBnaXZlIGVhY2ggZXh0ZW5zaW9uIGEgY2hhbmNlIHRvIHVzZSB0aGUgdGFzayBkZWZpbml0aW9uXG4gICAgZm9yIChjb25zdCBleHRlbnNpb25zIGluIHRoaXMuc2VydmljZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zW2V4dGVuc2lvbnNdKSB7XG4gICAgICAgIHRoaXMuc2VydmljZURlc2NyaXB0aW9uLmV4dGVuc2lvbnNbZXh0ZW5zaW9uc10udXNlVGFza0RlZmluaXRpb24odGhpcy50YXNrRGVmaW5pdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgYWxsIGNvbnRhaW5lcnMgYXJlIGNyZWF0ZWQsIGdpdmUgZWFjaCBleHRlbnNpb24gYSBjaGFuY2VcbiAgICAvLyB0byBiYWtlIGl0cyBkZXBlbmRlbmN5IGdyYXBoXG4gICAgZm9yIChjb25zdCBleHRlbnNpb25zIGluIHRoaXMuc2VydmljZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zW2V4dGVuc2lvbnNdKSB7XG4gICAgICAgIHRoaXMuc2VydmljZURlc2NyaXB0aW9uLmV4dGVuc2lvbnNbZXh0ZW5zaW9uc10ucmVzb2x2ZUNvbnRhaW5lckRlcGVuZGVuY2llcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdpdmUgZWFjaCBleHRlbnNpb24gYSBjaGFuY2UgdG8gbXV0YXRlIHRoZSBzZXJ2aWNlIHByb3BzIGJlZm9yZVxuICAgIC8vIHNlcnZpY2UgY3JlYXRpb25cbiAgICBsZXQgc2VydmljZVByb3BzID0ge1xuICAgICAgY2x1c3RlcjogdGhpcy5jbHVzdGVyLFxuICAgICAgdGFza0RlZmluaXRpb246IHRoaXMudGFza0RlZmluaXRpb24sXG4gICAgICBtaW5IZWFsdGh5UGVyY2VudDogMTAwLFxuICAgICAgbWF4SGVhbHRoeVBlcmNlbnQ6IDIwMCxcbiAgICAgIGRlc2lyZWRDb3VudDogMSxcbiAgICB9IGFzIFNlcnZpY2VCdWlsZDtcblxuICAgIGZvciAoY29uc3QgZXh0ZW5zaW9ucyBpbiB0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlRGVzY3JpcHRpb24uZXh0ZW5zaW9uc1tleHRlbnNpb25zXSkge1xuICAgICAgICBzZXJ2aWNlUHJvcHMgPSB0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zW2V4dGVuc2lvbnNdLm1vZGlmeVNlcnZpY2VQcm9wcyhzZXJ2aWNlUHJvcHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGEgbWF4SGVhbHRoeVBlcmNlbnQgYW5kIGRlc2lyZWQgY291bnQgaGFzIGJlZW4gc2V0IHdoaWxlIG1pbkhlYWx0aHlQZXJjZW50ID09IDEwMCUgdGhlbiB3ZVxuICAgIC8vIG5lZWQgdG8gZG8gc29tZSBmYWlsc2FmZSBjaGVja2luZyB0byBlbnN1cmUgdGhhdCB0aGUgbWF4SGVhbHRoeVBlcmNlbnRcbiAgICAvLyBhY3R1YWxseSBhbGxvd3MgYSByb2xsaW5nIGRlcGxveS4gT3RoZXJ3aXNlIGl0IGlzIHBvc3NpYmxlIHRvIGVuZCB1cCB3aXRoXG4gICAgLy8gYmxvY2tlZCBkZXBsb3lzIHRoYXQgY2FuIHRha2Ugbm8gYWN0aW9uIGJlY2F1c2UgbWluSGVhbHR5aFBlcmNlbnQgPT0gMTAwJVxuICAgIC8vIHByZXZlbnRzIHJ1bm5pbmcsIGhlYWx0aHkgdGFza3MgZnJvbSBiZWluZyBzdG9wcGVkLCBidXQgYSBsb3cgbWF4SGVhbHRoeVBlcmNlbnRcbiAgICAvLyBjYW4gYWxzbyBwcmV2ZW50cyBuZXcgcGFyYWxsZWwgdGFza3MgZnJvbSBiZWluZyBzdGFydGVkLlxuICAgIGlmIChzZXJ2aWNlUHJvcHMubWF4SGVhbHRoeVBlcmNlbnQgJiYgc2VydmljZVByb3BzLmRlc2lyZWRDb3VudCAmJiBzZXJ2aWNlUHJvcHMubWluSGVhbHRoeVBlcmNlbnQgJiYgc2VydmljZVByb3BzLm1pbkhlYWx0aHlQZXJjZW50ID09IDEwMCkge1xuICAgICAgaWYgKHNlcnZpY2VQcm9wcy5kZXNpcmVkQ291bnQgPT0gMSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmUgdGFzayB0aGVuIHdlIG11c3QgYWxsb3cgbWF4IHBlcmNlbnRhZ2UgdG8gYmUgYXRcbiAgICAgICAgLy8gbGVhc3QgMjAwJSBmb3IgYW5vdGhlciByZXBsYWNlbWVudCB0YXNrIHRvIGJlIGFkZGVkXG4gICAgICAgIHNlcnZpY2VQcm9wcyA9IHtcbiAgICAgICAgICAuLi5zZXJ2aWNlUHJvcHMsXG4gICAgICAgICAgbWF4SGVhbHRoeVBlcmNlbnQ6IE1hdGgubWF4KDIwMCwgc2VydmljZVByb3BzLm1heEhlYWx0aHlQZXJjZW50KSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoc2VydmljZVByb3BzLmRlc2lyZWRDb3VudCA8PSAzKSB7XG4gICAgICAgIC8vIElmIHRhc2sgY291bnQgaXMgMiBvciAzIHRoZW4gbWF4IHBlcmNlbnQgbXVzdCBiZSBhdCBsZWFzdCAxNTAlIHRvXG4gICAgICAgIC8vIGFsbG93IG9uZSByZXBsYWNlbWVudCB0YXNrIHRvIGJlIGxhdW5jaGVkIGF0IGEgdGltZS5cbiAgICAgICAgc2VydmljZVByb3BzID0ge1xuICAgICAgICAgIC4uLnNlcnZpY2VQcm9wcyxcbiAgICAgICAgICBtYXhIZWFsdGh5UGVyY2VudDogTWF0aC5tYXgoMTUwLCBzZXJ2aWNlUHJvcHMubWF4SGVhbHRoeVBlcmNlbnQpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIGFueXRoaW5nIGhpZ2hlciB0aGFuIDMgdGFza3Mgc2V0IG1heCBwZXJjZW50IHRvIGF0IGxlYXN0IDEyNSVcbiAgICAgICAgLy8gRm9yIDQgdGFza3MgdGhpcyB3aWxsIGFsbG93IGV4YWN0bHkgb25lIGV4dHJhIHJlcGxhY2VtZW50IHRhc2tcbiAgICAgICAgLy8gYXQgYSB0aW1lLCBmb3IgYW55IGhpZ2hlciB0YXNrIGNvdW50IGl0IHdpbGwgYWxsb3cgMjUlIG9mIHRoZSB0YXNrc1xuICAgICAgICAvLyB0byBiZSByZXBsYWNlZCBhdCBhIHRpbWUuXG4gICAgICAgIHNlcnZpY2VQcm9wcyA9IHtcbiAgICAgICAgICAuLi5zZXJ2aWNlUHJvcHMsXG4gICAgICAgICAgbWF4SGVhbHRoeVBlcmNlbnQ6IE1hdGgubWF4KDEyNSwgc2VydmljZVByb3BzLm1heEhlYWx0aHlQZXJjZW50KSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3cgdGhhdCB0aGUgc2VydmljZSBwcm9wcyBhcmUgZGV0ZXJtaW5lZCB3ZSBjYW4gY3JlYXRlXG4gICAgLy8gdGhlIHNlcnZpY2VcbiAgICBpZiAodGhpcy5jYXBhY2l0eVR5cGUgPT09IEVudmlyb25tZW50Q2FwYWNpdHlUeXBlLkVDMikge1xuICAgICAgdGhpcy5lY3NTZXJ2aWNlID0gbmV3IGVjcy5FYzJTZXJ2aWNlKHRoaXMuc2NvcGUsIGAke3RoaXMuaWR9LXNlcnZpY2VgLCBzZXJ2aWNlUHJvcHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jYXBhY2l0eVR5cGUgPT09IEVudmlyb25tZW50Q2FwYWNpdHlUeXBlLkZBUkdBVEUpIHtcbiAgICAgIHRoaXMuZWNzU2VydmljZSA9IG5ldyBlY3MuRmFyZ2F0ZVNlcnZpY2UodGhpcy5zY29wZSwgYCR7dGhpcy5pZH0tc2VydmljZWAsIHNlcnZpY2VQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjYXBhY2l0eSB0eXBlIGZvciBzZXJ2aWNlICR7dGhpcy5pZH1gKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgZ2l2ZSBhbGwgZXh0ZW5zaW9ucyBhIGNoYW5jZSB0byB1c2UgdGhlIHNlcnZpY2VcbiAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbnMgaW4gdGhpcy5zZXJ2aWNlRGVzY3JpcHRpb24uZXh0ZW5zaW9ucykge1xuICAgICAgaWYgKHRoaXMuc2VydmljZURlc2NyaXB0aW9uLmV4dGVuc2lvbnNbZXh0ZW5zaW9uc10pIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlRGVzY3JpcHRpb24uZXh0ZW5zaW9uc1tleHRlbnNpb25zXS51c2VTZXJ2aWNlKHRoaXMuZWNzU2VydmljZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRlbGwgZXh0ZW5zaW9ucyBmcm9tIG9uZSBzZXJ2aWNlIHRvIGNvbm5lY3QgdG8gZXh0ZW5zaW9ucyBmcm9tXG4gICAqIGFub3RoZXIgc2V2aWNlIGlmIHRoZXkgaGF2ZSBpbXBsZW1lbnRlZCBhIGhvb2sgZm9yIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmljZVxuICAgKi9cbiAgcHVibGljIGNvbm5lY3RUbyhzZXJ2aWNlOiBTZXJ2aWNlKSB7XG4gICAgZm9yIChjb25zdCBleHRlbnNpb25zIGluIHRoaXMuc2VydmljZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2VEZXNjcmlwdGlvbi5leHRlbnNpb25zW2V4dGVuc2lvbnNdKSB7XG4gICAgICAgIHRoaXMuc2VydmljZURlc2NyaXB0aW9uLmV4dGVuc2lvbnNbZXh0ZW5zaW9uc10uY29ubmVjdFRvU2VydmljZShzZXJ2aWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyBhIG5ldyBVUkwgZm9yIHRoZSBzZXJ2aWNlLiBUaGlzIGFsbG93cyBleHRlbnNpb25zIHRvXG4gICAqIHN1Ym1pdCBhIFVSTCBmb3IgdGhlIHNlcnZpY2UuIEZvciBleGFtcGxlLCBhIGxvYWQgYmFsYW5jZXIgbWlnaHQgYWRkIGl0c1xuICAgKiBVUkwsIG9yIEFwcCBNZXNoIGNhbiBhZGQgaXRzIEROUyBuYW1lIGZvciB0aGUgc2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHVybE5hbWUgLSBUaGUgaWRlbnRpZmllciBuYW1lIGZvciB0aGlzIFVSTFxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBpdHNlbGYuXG4gICAqL1xuICBwdWJsaWMgYWRkVVJMKHVybE5hbWU6IHN0cmluZywgdXJsOiBzdHJpbmcpIHtcbiAgICB0aGlzLnVybHNbdXJsTmFtZV0gPSB1cmw7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBVUkwgZm9yIHRoZSBzZXJ2aWNlLiBUaGUgVVJMIG11c3QgaGF2ZSBwcmV2aW91c2x5IGJlZW5cbiAgICogc3RvcmVkIGJ5IG9uZSBvZiB0aGUgVVJMIHByb3ZpZGluZyBleHRlbnNpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsTmFtZSAtIFRoZSBVUkwgdG8gbG9vayB1cC5cbiAgICovXG4gIHB1YmxpYyBnZXRVUkwodXJsTmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLnVybHNbdXJsTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYSBVUkwgd2l0aCBuYW1lICcke3VybE5hbWV9J2ApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnVybHNbdXJsTmFtZV07XG4gIH1cbn1cbiJdfQ==