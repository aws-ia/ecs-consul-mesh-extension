"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addToDeadLetterQueueResourcePolicy = exports.addLambdaPermission = exports.singletonEventRole = exports.bindBaseTargetConfig = void 0;
const iam = require("@aws-cdk/aws-iam");
const core_1 = require("@aws-cdk/core");
// keep this import separate from other imports to reduce chance for merge conflicts with v2-main
// eslint-disable-next-line no-duplicate-imports, import/order
const core_2 = require("@aws-cdk/core");
/**
 * Bind props to base rule target config.
 * @internal
 */
function bindBaseTargetConfig(props) {
    let { deadLetterQueue, retryAttempts, maxEventAge } = props;
    return {
        deadLetterConfig: deadLetterQueue ? { arn: deadLetterQueue === null || deadLetterQueue === void 0 ? void 0 : deadLetterQueue.queueArn } : undefined,
        retryPolicy: retryAttempts || maxEventAge
            ? {
                maximumRetryAttempts: retryAttempts,
                maximumEventAgeInSeconds: maxEventAge === null || maxEventAge === void 0 ? void 0 : maxEventAge.toSeconds({ integral: true }),
            }
            : undefined,
    };
}
exports.bindBaseTargetConfig = bindBaseTargetConfig;
/**
 * Obtain the Role for the EventBridge event
 *
 * If a role already exists, it will be returned. This ensures that if multiple
 * events have the same target, they will share a role.
 * @internal
 */
function singletonEventRole(scope, policyStatements) {
    const id = 'EventsRole';
    const existing = scope.node.tryFindChild(id);
    if (existing) {
        return existing;
    }
    const role = new iam.Role(scope, id, {
        roleName: core_1.PhysicalName.GENERATE_IF_NEEDED,
        assumedBy: new iam.ServicePrincipal('events.amazonaws.com'),
    });
    policyStatements.forEach(role.addToPolicy.bind(role));
    return role;
}
exports.singletonEventRole = singletonEventRole;
/**
 * Allows a Lambda function to be called from a rule
 * @internal
 */
function addLambdaPermission(rule, handler) {
    let scope;
    let node = handler.permissionsNode;
    let permissionId = `AllowEventRule${core_1.Names.nodeUniqueId(rule.node)}`;
    if (rule instanceof core_2.Construct) {
        // Place the Permission resource in the same stack as Rule rather than the Function
        // This is to reduce circular dependency when the lambda handler and the rule are across stacks.
        scope = rule;
        node = rule.node;
        permissionId = `AllowEventRule${core_1.Names.nodeUniqueId(handler.node)}`;
    }
    if (!node.tryFindChild(permissionId)) {
        handler.addPermission(permissionId, {
            scope,
            action: 'lambda:InvokeFunction',
            principal: new iam.ServicePrincipal('events.amazonaws.com'),
            sourceArn: rule.ruleArn,
        });
    }
}
exports.addLambdaPermission = addLambdaPermission;
/**
 * Allow a rule to send events with failed invocation to an Amazon SQS queue.
 * @internal
 */
function addToDeadLetterQueueResourcePolicy(rule, queue) {
    if (!sameEnvDimension(rule.env.region, queue.env.region)) {
        throw new Error(`Cannot assign Dead Letter Queue in region ${queue.env.region} to the rule ${core_1.Names.nodeUniqueId(rule.node)} in region ${rule.env.region}. Both the queue and the rule must be in the same region.`);
    }
    // Skip Resource Policy creation if the Queue is not in the same account.
    // There is no way to add a target onto an imported rule, so we can assume we will run the following code only
    // in the account where the rule is created.
    if (sameEnvDimension(rule.env.account, queue.env.account)) {
        const policyStatementId = `AllowEventRule${core_1.Names.nodeUniqueId(rule.node)}`;
        queue.addToResourcePolicy(new iam.PolicyStatement({
            sid: policyStatementId,
            principals: [new iam.ServicePrincipal('events.amazonaws.com')],
            effect: iam.Effect.ALLOW,
            actions: ['sqs:SendMessage'],
            resources: [queue.queueArn],
            conditions: {
                ArnEquals: {
                    'aws:SourceArn': rule.ruleArn,
                },
            },
        }));
    }
    else {
        core_1.Annotations.of(rule).addWarning(`Cannot add a resource policy to your dead letter queue associated with rule ${rule.ruleName} because the queue is in a different account. You must add the resource policy manually to the dead letter queue in account ${queue.env.account}.`);
    }
}
exports.addToDeadLetterQueueResourcePolicy = addToDeadLetterQueueResourcePolicy;
/**
 * Whether two string probably contain the same environment dimension (region or account)
 *
 * Used to compare either accounts or regions, and also returns true if both
 * are unresolved (in which case both are expted to be "current region" or "current account").
 * @internal
 */
function sameEnvDimension(dim1, dim2) {
    return [core_1.TokenComparison.SAME, core_1.TokenComparison.BOTH_UNRESOLVED].includes(core_1.Token.compareStrings(dim1, dim2));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0Esd0NBQXdDO0FBR3hDLHdDQUE4SDtBQUU5SCxpR0FBaUc7QUFDakcsOERBQThEO0FBQzlELHdDQUEwQztBQWExQzs7O0dBR0c7QUFDSCxTQUFnQixvQkFBb0IsQ0FBQyxLQUFzQjtJQUN6RCxJQUFJLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsR0FBRyxLQUFLLENBQUM7SUFFNUQsT0FBTztRQUNMLGdCQUFnQixFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsZUFBZSxhQUFmLGVBQWUsdUJBQWYsZUFBZSxDQUFFLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTO1FBQ2xGLFdBQVcsRUFBRSxhQUFhLElBQUksV0FBVztZQUN2QyxDQUFDLENBQUM7Z0JBQ0Esb0JBQW9CLEVBQUUsYUFBYTtnQkFDbkMsd0JBQXdCLEVBQUUsV0FBVyxhQUFYLFdBQVcsdUJBQVgsV0FBVyxDQUFFLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQzthQUNyRTtZQUNELENBQUMsQ0FBQyxTQUFTO0tBQ2QsQ0FBQztBQUNKLENBQUM7QUFaRCxvREFZQztBQUdEOzs7Ozs7R0FNRztBQUNILFNBQWdCLGtCQUFrQixDQUFDLEtBQWlCLEVBQUUsZ0JBQXVDO0lBQzNGLE1BQU0sRUFBRSxHQUFHLFlBQVksQ0FBQztJQUN4QixNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQWMsQ0FBQztJQUMxRCxJQUFJLFFBQVEsRUFBRTtRQUFFLE9BQU8sUUFBUSxDQUFDO0tBQUU7SUFFbEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQWtCLEVBQUUsRUFBRSxFQUFFO1FBQ2hELFFBQVEsRUFBRSxtQkFBWSxDQUFDLGtCQUFr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QUMsT0FBTyxHQUFHLENBQUMsQ0FBQztLQUNsUjtBQUNILENBQUM7QUExQkQsZ0ZBMEJDO0FBR0Q7Ozs7OztHQU1HO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFZLEVBQUUsSUFBWTtJQUNsRCxPQUFPLENBQUMsc0JBQWUsQ0FBQyxJQUFJLEVBQUUsc0JBQWUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxRQUFRLENBQUMsWUFBSyxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUM1RyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJ0Bhd3MtY2RrL2F3cy1ldmVudHMnO1xuaW1wb3J0ICogYXMgaWFtIGZyb20gJ0Bhd3MtY2RrL2F3cy1pYW0nO1xuaW1wb3J0ICogYXMgbGFtYmRhIGZyb20gJ0Bhd3MtY2RrL2F3cy1sYW1iZGEnO1xuaW1wb3J0ICogYXMgc3FzIGZyb20gJ0Bhd3MtY2RrL2F3cy1zcXMnO1xuaW1wb3J0IHsgQW5ub3RhdGlvbnMsIENvbnN0cnVjdE5vZGUsIElDb25zdHJ1Y3QsIE5hbWVzLCBUb2tlbiwgVG9rZW5Db21wYXJpc29uLCBEdXJhdGlvbiwgUGh5c2ljYWxOYW1lIH0gZnJvbSAnQGF3cy1jZGsvY29yZSc7XG5cbi8vIGtlZXAgdGhpcyBpbXBvcnQgc2VwYXJhdGUgZnJvbSBvdGhlciBpbXBvcnRzIHRvIHJlZHVjZSBjaGFuY2UgZm9yIG1lcmdlIGNvbmZsaWN0cyB3aXRoIHYyLW1haW5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBsaWNhdGUtaW1wb3J0cywgaW1wb3J0L29yZGVyXG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdAYXdzLWNkay9jb3JlJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5leHBvcnQgaW50ZXJmYWNlIFRhcmdldEJhc2VQcm9wcyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgZGVhZExldHRlclF1ZXVlPzogc3FzLklRdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgbWF4RXZlbnRBZ2U/OiBEdXJhdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSByZXRyeUF0dGVtcHRzPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEJpbmQgcHJvcHMgdG8gYmFzZSBydWxlIHRhcmdldCBjb25maWcuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRCYXNlVGFyZ2V0Q29uZmlnKHByb3BzOiBUYXJnZXRCYXNlUHJvcHMpIHtcbiAgbGV0IHsgZGVhZExldHRlclF1ZXVlLCByZXRyeUF0dGVtcHRzLCBtYXhFdmVudEFnZSB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIHtcbiAgICBkZWFkTGV0dGVyQ29uZmlnOiBkZWFkTGV0dGVyUXVldWUgPyB7IGFybjogZGVhZExldHRlclF1ZXVlPy5xdWV1ZUFybiB9IDogdW5kZWZpbmVkLFxuICAgIHJldHJ5UG9saWN5OiByZXRyeUF0dGVtcHRzIHx8IG1heEV2ZW50QWdlXG4gICAgICA/IHtcbiAgICAgICAgbWF4aW11bVJldHJ5QXR0ZW1wdHM6IHJldHJ5QXR0ZW1wdHMsXG4gICAgICAgIG1heGltdW1FdmVudEFnZUluU2Vjb25kczogbWF4RXZlbnRBZ2U/LnRvU2Vjb25kcyh7IGludGVncmFsOiB0cnVlIH0pLFxuICAgICAgfVxuICAgICAgOiB1bmRlZmluZWQsXG4gIH07XG59XG5cblxuLyoqXG4gKiBPYnRhaW4gdGhlIFJvbGUgZm9yIHRoZSBFdmVudEJyaWRnZSBldmVudFxuICpcbiAqIElmIGEgcm9sZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBiZSByZXR1cm5lZC4gVGhpcyBlbnN1cmVzIHRoYXQgaWYgbXVsdGlwbGVcbiAqIGV2ZW50cyBoYXZlIHRoZSBzYW1lIHRhcmdldCwgdGhleSB3aWxsIHNoYXJlIGEgcm9sZS5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZ2xldG9uRXZlbnRSb2xlKHNjb3BlOiBJQ29uc3RydWN0LCBwb2xpY3lTdGF0ZW1lbnRzOiBpYW0uUG9saWN5U3RhdGVtZW50W10pOiBpYW0uSVJvbGUge1xuICBjb25zdCBpZCA9ICdFdmVudHNSb2xlJztcbiAgY29uc3QgZXhpc3RpbmcgPSBzY29wZS5ub2RlLnRyeUZpbmRDaGlsZChpZCkgYXMgaWFtLklSb2xlO1xuICBpZiAoZXhpc3RpbmcpIHsgcmV0dXJuIGV4aXN0aW5nOyB9XG5cbiAgY29uc3Qgcm9sZSA9IG5ldyBpYW0uUm9sZShzY29wZSBhcyBDb25zdHJ1Y3QsIGlkLCB7XG4gICAgcm9sZU5hbWU6IFBoeXNpY2FsTmFtZS5HRU5FUkFURV9JRl9ORUVERUQsXG4gICAgYXNzdW1lZEJ5OiBuZXcgaWFtLlNlcnZpY2VQcmluY2lwYWwoJ2V2ZW50cy5hbWF6b25hd3MuY29tJyksXG4gIH0pO1xuXG4gIHBvbGljeVN0YXRlbWVudHMuZm9yRWFjaChyb2xlLmFkZFRvUG9saWN5LmJpbmQocm9sZSkpO1xuXG4gIHJldHVybiByb2xlO1xufVxuXG4vKipcbiAqIEFsbG93cyBhIExhbWJkYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZnJvbSBhIHJ1bGVcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTGFtYmRhUGVybWlzc2lvbihydWxlOiBldmVudHMuSVJ1bGUsIGhhbmRsZXI6IGxhbWJkYS5JRnVuY3Rpb24pOiB2b2lkIHtcbiAgbGV0IHNjb3BlOiBDb25zdHJ1Y3QgfCB1bmRlZmluZWQ7XG4gIGxldCBub2RlOiBDb25zdHJ1Y3ROb2RlID0gaGFuZGxlci5wZXJtaXNzaW9uc05vZGU7XG4gIGxldCBwZXJtaXNzaW9uSWQgPSBgQWxsb3dFdmVudFJ1bGUke05hbWVzLm5vZGVVbmlxdWVJZChydWxlLm5vZGUpfWA7XG4gIGlmIChydWxlIGluc3RhbmNlb2YgQ29uc3RydWN0KSB7XG4gICAgLy8gUGxhY2UgdGhlIFBlcm1pc3Npb24gcmVzb3VyY2UgaW4gdGhlIHNhbWUgc3RhY2sgYXMgUnVsZSByYXRoZXIgdGhhbiB0aGUgRnVuY3Rpb25cbiAgICAvLyBUaGlzIGlzIHRvIHJlZHVjZSBjaXJjdWxhciBkZXBlbmRlbmN5IHdoZW4gdGhlIGxhbWJkYSBoYW5kbGVyIGFuZCB0aGUgcnVsZSBhcmUgYWNyb3NzIHN0YWNrcy5cbiAgICBzY29wZSA9IHJ1bGU7XG4gICAgbm9kZSA9IHJ1bGUubm9kZTtcbiAgICBwZXJtaXNzaW9uSWQgPSBgQWxsb3dFdmVudFJ1bGUke05hbWVzLm5vZGVVbmlxdWVJZChoYW5kbGVyLm5vZGUpfWA7XG4gIH1cbiAgaWYgKCFub2RlLnRyeUZpbmRDaGlsZChwZXJtaXNzaW9uSWQpKSB7XG4gICAgaGFuZGxlci5hZGRQZXJtaXNzaW9uKHBlcm1pc3Npb25JZCwge1xuICAgICAgc2NvcGUsXG4gICAgICBhY3Rpb246ICdsYW1iZGE6SW52b2tlRnVuY3Rpb24nLFxuICAgICAgcHJpbmNpcGFsOiBuZXcgaWFtLlNlcnZpY2VQcmluY2lwYWwoJ2V2ZW50cy5hbWF6b25hd3MuY29tJyksXG4gICAgICBzb3VyY2VBcm46IHJ1bGUucnVsZUFybixcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEFsbG93IGEgcnVsZSB0byBzZW5kIGV2ZW50cyB3aXRoIGZhaWxlZCBpbnZvY2F0aW9uIHRvIGFuIEFtYXpvbiBTUVMgcXVldWUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFRvRGVhZExldHRlclF1ZXVlUmVzb3VyY2VQb2xpY3kocnVsZTogZXZlbnRzLklSdWxlLCBxdWV1ZTogc3FzLklRdWV1ZSkge1xuICBpZiAoIXNhbWVFbnZEaW1lbnNpb24ocnVsZS5lbnYucmVnaW9uLCBxdWV1ZS5lbnYucmVnaW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFzc2lnbiBEZWFkIExldHRlciBRdWV1ZSBpbiByZWdpb24gJHtxdWV1ZS5lbnYucmVnaW9ufSB0byB0aGUgcnVsZSAke05hbWVzLm5vZGVVbmlxdWVJZChydWxlLm5vZGUpfSBpbiByZWdpb24gJHtydWxlLmVudi5yZWdpb259LiBCb3RoIHRoZSBxdWV1ZSBhbmQgdGhlIHJ1bGUgbXVzdCBiZSBpbiB0aGUgc2FtZSByZWdpb24uYCk7XG4gIH1cblxuICAvLyBTa2lwIFJlc291cmNlIFBvbGljeSBjcmVhdGlvbiBpZiB0aGUgUXVldWUgaXMgbm90IGluIHRoZSBzYW1lIGFjY291bnQuXG4gIC8vIFRoZXJlIGlzIG5vIHdheSB0byBhZGQgYSB0YXJnZXQgb250byBhbiBpbXBvcnRlZCBydWxlLCBzbyB3ZSBjYW4gYXNzdW1lIHdlIHdpbGwgcnVuIHRoZSBmb2xsb3dpbmcgY29kZSBvbmx5XG4gIC8vIGluIHRoZSBhY2NvdW50IHdoZXJlIHRoZSBydWxlIGlzIGNyZWF0ZWQuXG4gIGlmIChzYW1lRW52RGltZW5zaW9uKHJ1bGUuZW52LmFjY291bnQsIHF1ZXVlLmVudi5hY2NvdW50KSkge1xuICAgIGNvbnN0IHBvbGljeVN0YXRlbWVudElkID0gYEFsbG93RXZlbnRSdWxlJHtOYW1lcy5ub2RlVW5pcXVlSWQocnVsZS5ub2RlKX1gO1xuXG4gICAgcXVldWUuYWRkVG9SZXNvdXJjZVBvbGljeShuZXcgaWFtLlBvbGljeVN0YXRlbWVudCh7XG4gICAgICBzaWQ6IHBvbGljeVN0YXRlbWVudElkLFxuICAgICAgcHJpbmNpcGFsczogW25ldyBpYW0uU2VydmljZVByaW5jaXBhbCgnZXZlbnRzLmFtYXpvbmF3cy5jb20nKV0sXG4gICAgICBlZmZlY3Q6IGlhbS5FZmZlY3QuQUxMT1csXG4gICAgICBhY3Rpb25zOiBbJ3NxczpTZW5kTWVzc2FnZSddLFxuICAgICAgcmVzb3VyY2VzOiBbcXVldWUucXVldWVBcm5dLFxuICAgICAgY29uZGl0aW9uczoge1xuICAgICAgICBBcm5FcXVhbHM6IHtcbiAgICAgICAgICAnYXdzOlNvdXJjZUFybic6IHJ1bGUucnVsZUFybixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIEFubm90YXRpb25zLm9mKHJ1bGUpLmFkZFdhcm5pbmcoYENhbm5vdCBhZGQgYSByZXNvdXJjZSBwb2xpY3kgdG8geW91ciBkZWFkIGxldHRlciBxdWV1ZSBhc3NvY2lhdGVkIHdpdGggcnVsZSAke3J1bGUucnVsZU5hbWV9IGJlY2F1c2UgdGhlIHF1ZXVlIGlzIGluIGEgZGlmZmVyZW50IGFjY291bnQuIFlvdSBtdXN0IGFkZCB0aGUgcmVzb3VyY2UgcG9saWN5IG1hbnVhbGx5IHRvIHRoZSBkZWFkIGxldHRlciBxdWV1ZSBpbiBhY2NvdW50ICR7cXVldWUuZW52LmFjY291bnR9LmApO1xuICB9XG59XG5cblxuLyoqXG4gKiBXaGV0aGVyIHR3byBzdHJpbmcgcHJvYmFibHkgY29udGFpbiB0aGUgc2FtZSBlbnZpcm9ubWVudCBkaW1lbnNpb24gKHJlZ2lvbiBvciBhY2NvdW50KVxuICpcbiAqIFVzZWQgdG8gY29tcGFyZSBlaXRoZXIgYWNjb3VudHMgb3IgcmVnaW9ucywgYW5kIGFsc28gcmV0dXJucyB0cnVlIGlmIGJvdGhcbiAqIGFyZSB1bnJlc29sdmVkIChpbiB3aGljaCBjYXNlIGJvdGggYXJlIGV4cHRlZCB0byBiZSBcImN1cnJlbnQgcmVnaW9uXCIgb3IgXCJjdXJyZW50IGFjY291bnRcIikuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc2FtZUVudkRpbWVuc2lvbihkaW0xOiBzdHJpbmcsIGRpbTI6IHN0cmluZykge1xuICByZXR1cm4gW1Rva2VuQ29tcGFyaXNvbi5TQU1FLCBUb2tlbkNvbXBhcmlzb24uQk9USF9VTlJFU09MVkVEXS5pbmNsdWRlcyhUb2tlbi5jb21wYXJlU3RyaW5ncyhkaW0xLCBkaW0yKSk7XG59Il19